/* Copyright 2015 Samsung Electronics Co., LTD * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.gearvrf.modelviewer2;import org.gearvrf.GVRActivity;import org.gearvrf.GVRAndroidResource;import org.gearvrf.GVRContext;import org.gearvrf.GVREyePointeeHolder;import org.gearvrf.GVRMaterial;import org.gearvrf.GVRMesh;import org.gearvrf.GVRMeshEyePointee;import org.gearvrf.GVRPicker;import org.gearvrf.GVRRenderData;import org.gearvrf.GVRScene;import org.gearvrf.GVRSceneObject;import org.gearvrf.GVRScript;import org.gearvrf.GVRTexture;import org.gearvrf.scene_objects.GVRModelSceneObject;import org.gearvrf.scene_objects.GVRSphereSceneObject;import org.gearvrf.scene_objects.GVRTextViewSceneObject;import org.gearvrf.util.AccessibilitySceneShader;import org.gearvrf.util.BoundingBoxCreator;import org.gearvrf.util.VRTouchPadGestureDetector.SwipeDirection;import org.gearvrf.animation.GVRAnimation;import org.gearvrf.widgetplugin.GVRWidgetPlugin;import org.gearvrf.widgetplugin.GVRWidgetSceneObject;import org.gearvrf.widgetplugin.GVRWidgetSceneObjectMeshInfo;import org.joml.Vector3f;import android.opengl.GLES20;import android.os.Environment;import android.util.Log;import android.view.MotionEvent;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.ArrayList;import java.util.Stack;public class ModelViewer2Manager extends GVRScript {    private static final String TAG = "Abhijit";    // Variables related to Room    private final String mRoomPath = "room.fbx";    private GVRContext mGVRContext;    private GVRModelSceneObject mRoom;    private Controller controller;    public boolean controllerReadyFlag = false;    private GVRScene scene;    private boolean mIsSingleTapped = false;    GVRSceneObject headTracker;    GVRWidgetPlugin mPlugin;    GVRWidgetSceneObject mWidget;    GVRActivity activity;    private Vector3f defaultCameraPosition = new Vector3f(0, 200, 1000);    public ModelViewer2Manager(GVRActivity activity, GVRWidgetPlugin mPlugin) {        this.mPlugin = mPlugin;        this.activity = activity;    }    private GVRModelSceneObject loadModelFile(GVRContext gvrContext, String modelFile) {        try {            return gvrContext.loadModel(modelFile);        } catch (IOException e) {            e.printStackTrace();        }        return null;    }    private GVRTexture loadTexture(GVRContext gvrContext, String imageFile) {        try {            return gvrContext.loadTexture(new GVRAndroidResource(gvrContext, imageFile));        } catch (IOException e) {            e.printStackTrace();        }        return null;    }    private GVRSceneObject getHeadTracker() {        // Head Tracker        GVRTexture headTrackerTexture = loadTexture(mGVRContext, "head-tracker.png");        headTracker = new GVRSceneObject(mGVRContext,                mGVRContext.createQuad(0.5f, 0.5f), headTrackerTexture);        headTracker.getTransform().setPositionZ(-9.0f);        headTracker.getRenderData().setRenderingOrder(                GVRRenderData.GVRRenderingOrder.OVERLAY);        headTracker.getRenderData().setDepthTest(false);        headTracker.getRenderData().setRenderingOrder(100000);        return headTracker;    }    void addWidgetToTheRoom() {        GVRWidgetSceneObjectMeshInfo info =                new GVRWidgetSceneObjectMeshInfo(-4.5f, 1.0f, -1.5f, -1.0f, new int[]{0, 0}, new int[]{1280 * 2, 1440 * 2});        mWidget = new GVRWidgetSceneObject(mGVRContext,                mPlugin.getTextureId(), info, mPlugin.getWidth(),                mPlugin.getHeight());        Log.e(TAG, Float.toString(mPlugin.getHeight()) + "   " + Float.toString(mPlugin.getWidth()));        mWidget.getTransform().setPosition(defaultCameraPosition.x - 3.0f, defaultCameraPosition.y, defaultCameraPosition.z - 5);        mWidget.getTransform().rotateByAxis(40.0f, 0.0f, 1.0f, 0.0f);        mWidget.getRenderData().setRenderingOrder(                GVRRenderData.GVRRenderingOrder.OVERLAY);        mWidget.getRenderData().setDepthTest(false);        mWidget.getRenderData().setRenderingOrder(10000);        scene.addSceneObject(mWidget);        GVRMesh button_pick_mesh = null;        try {            button_pick_mesh = mGVRContext                    .loadMesh(new GVRAndroidResource(mGVRContext, "widgetEyePointee.obj"));        } catch (IOException e) {            e.printStackTrace();            Log.e(TAG, "Execption for button");        }        GVREyePointeeHolder eyePointeeHolder2 = new GVREyePointeeHolder(                mGVRContext);        GVRMeshEyePointee eyePointee2 = new GVRMeshEyePointee(mGVRContext,                button_pick_mesh);        eyePointeeHolder2.addPointee(eyePointee2);        mWidget.attachEyePointeeHolder(eyePointeeHolder2);    }    String readFile(String File) {        BufferedReader reader = null;        String readContents = "";        try {            reader = new BufferedReader(                    new InputStreamReader(activity.getAssets().open(File), "UTF-8"));            // do reading, usually loop until end of file reading            String mLine;            while ((mLine = reader.readLine()) != null) {                //process line                readContents += mLine;                readContents += "\n";            }        } catch (IOException e) {            e.printStackTrace();        }        return readContents;    }    private ShaderHandler attachTexture(GVRContext context, String modelPath, String vertexShaderPath, String fragmentShaderPath) {        ShaderHandler shaderHandler = new ShaderHandler(context);        GVRRenderData renderData = new GVRRenderData(context);        GVRMesh mesh = null;        GVRMaterial material = null;        try {            String vertexShader = readFile(vertexShaderPath);            String fragmentShader = readFile(fragmentShaderPath);            shaderHandler.addVSandFS(vertexShader, fragmentShader);            // material = new GVRMaterial(context, shaderHandler.getShaderID());            mesh = context.loadMesh(new GVRAndroidResource(context, modelPath));        } catch (IOException e) {            e.printStackTrace();            System.out.print(e);        }        Log.e(TAG, "Shaders custom aadded");        return shaderHandler;/*        renderData.setMesh(mesh);        renderData.setMaterial(material);        return renderData;*/    }    private void applyShaderOnSkyBox(GVRSceneObject skyBox) {        AccessibilitySceneShader shader = new AccessibilitySceneShader(mGVRContext);        //skyBox.detachRenderData();        // applyShader(shader, skyBox);        // GVRRenderData renderData = new GVRRenderData(mGVRContext);        // Adding Pointee to Model/*        GVRSceneObject.BoundingVolume bv = skyBox.getBoundingVolume();        BoundingBoxCreator boundingBox = new BoundingBoxCreator(mGVRContext, bv);        GVRMesh mesh = boundingBox.getMesh();        GVRMaterial mat = new GVRMaterial(mGVRContext, shader.getShaderId());        renderData.setMesh(mesh);        renderData.setMaterial(mat);        skyBox.attachRenderData(renderData);*/        Stack<GVRSceneObject> all = new Stack<GVRSceneObject>();        applyShader(shader, skyBox);        for (int i = 0; i < skyBox.getChildrenCount(); i++) {            all.push(skyBox.getChildByIndex(i));        }        while (all.size() != 0) {            GVRSceneObject temp = all.pop();            applyShader(shader, temp);            for (int i = 0; i < temp.getChildrenCount(); i++) {                all.push(temp.getChildByIndex(i));            }        }       /* for (GVRSceneObject object : skyBox.getChildren()) {            Log.e(TAG, "ChildFound");            //applyShader(shader, object);            GVRRenderData renderData2 = new GVRRenderData(mGVRContext);         //   GVRSceneObject.BoundingVolume bv = object.getBoundingVolume();         //   BoundingBoxCreator boundingBox2 = new BoundingBoxCreator(mGVRContext, bv);         //   GVRMesh mesh2 = boundingBox2.getMesh();            if(object.getRenderData() != null){            if(object.getRenderData().getMesh() != null) {                Log.e(TAG, "ChildFound with Mesh");                GVRMesh mesh2 = object.getRenderData().getMesh();                GVRMaterial mat2 = new GVRMaterial(mGVRContext, shader.getShaderId());                renderData2.setMesh(mesh2);                renderData2.setMaterial(mat2);                object.attachRenderData(renderData2);            }            else{                Log.e(TAG, "ChildFound but no mesh");            }}            else{                Log.e(TAG, "ChildFound but no mesh");            }        }*/    }    private void applyShader(AccessibilitySceneShader shader, GVRSceneObject object) {        if (object != null && object.getRenderData() != null && object.getRenderData().getMaterial() != null) {            Log.e(TAG, "Render data foundd");            //object.getRenderData().getMaterial().setShaderType(shader.getShaderId());            GVRSceneObject.BoundingVolume bv = object.getBoundingVolume();            BoundingBoxCreator boundingBox2 = new BoundingBoxCreator(mGVRContext, bv);            GVRRenderData renderData2 = new GVRRenderData(mGVRContext);            GVRMaterial mat2 = new GVRMaterial(mGVRContext, shader.getShaderId());            renderData2.setMesh(boundingBox2.getMesh());            renderData2.setMaterial(mat2);            object.attachRenderData(renderData2);/*            GVRRenderData renderData = new GVRRenderData(mGVRContext);            GVRSceneObject.BoundingVolume bv = object.getBoundingVolume();            BoundingBoxCreator boundingBox2 = new BoundingBoxCreator(mGVRContext, bv);            GVRMesh mesh2 = boundingBox2.getMesh();            GVRMesh mesh = object.getRenderData().getMesh();            GVRMaterial mat = new GVRMaterial(mGVRContext, shader.getShaderId());            renderData.setMesh(mesh2);            renderData.setMaterial(mat);            object.attachRenderData(renderData);*/        }    }    @Override    public void onInit(final GVRContext gvrContext) {        mGVRContext = gvrContext;        scene = gvrContext.getNextMainScene();        // Add Head Tracker        scene.getMainCameraRig().addChildObject(getHeadTracker());        scene.getMainCameraRig().getTransform().setPosition(defaultCameraPosition.x, defaultCameraPosition.y, defaultCameraPosition.z);        // Set the near clipping plane.        scene.getMainCameraRig().setNearClippingDistance(0.1f);        // Set the far clipping plane.        scene.getMainCameraRig().setFarClippingDistance(4500.0f);        // Load the Room model twice        mRoom = loadModelFile(gvrContext, mRoomPath);        // Set Transformations        mRoom.getTransform().setPosition(0.0f, 0.0f, 0.0f);        //ShaderHandler renderData = attachTexture(mGVRContext, mRoomPath, "Holo.vert", "Holo.frag");        //applyShaderOnSkyBox(mRoom);        Log.e(TAG, "Controller initialization done");        controller = new Controller(activity, mGVRContext);        controller.initializeController();        controllerReadyFlag = true;        controller.addThumbNails(mRoom);        controller.displayCountInRoom(mRoom);        addWidgetToTheRoom();        // Adding Room to the Final Scene        scene.addSceneObject(mRoom);        // Add First SkyBox        addSkyBox(0);    }    ArrayList<String> getCameraPositionList() {        return controller.getCameraPositionList();    }    void addSkyBox(int index) {        controller.addSkyBox(index, scene);    }    void setCameraPosition(int index) {        Log.e(TAG, "Camera Position Chosed +" + Integer.toString(index));        controller.setCameraPosition(scene, mWidget, index);    }    ArrayList<String> getSkyBoxList() {        return controller.getSkyBoxList();    }    GVREyePointeeHolder getEyePointee() {        GVREyePointeeHolder[] pickedHolders = null;        pickedHolders = GVRPicker.pickScene(mGVRContext.getMainScene());        //Log.e(TAG, "Picked scene count" + Integer.toString(pickedHolders.length));        if (pickedHolders.length > 0)            return pickedHolders[0];        else            return null;    }    @Override    public void onStep() {        boolean isSingleTapped = mIsSingleTapped;        mIsSingleTapped = false;        GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT | GLES20.GL_DEPTH_BUFFER_BIT);        GVREyePointeeHolder pickedHolder = getEyePointee();        if (pickedHolder == null)            return;        // For Menu        mPlugin.setPickedObject(pickedHolder.getOwnerObject());        if (isSingleTapped) {            controller.displayModelIfSelected(pickedHolder, scene, mRoom, mWidget);        }    }    public void onSingleTap(MotionEvent e) {        Log.d(TAG, "On Single Touch Received");        mIsSingleTapped = true;    }    public void onSwipe(MotionEvent e, SwipeDirection swipeDirection,                        float velocityX, float velocityY) {        if (swipeDirection == SwipeDirection.Forward) {            // Swipe Only when Looking at ThumbNails            GVREyePointeeHolder pickedHolder = getEyePointee();            if (pickedHolder != null)                controller.onFowardSwipeOfThumbNails(pickedHolder, mRoom);            Log.d("SWIPE", "Swipped Forward");        } else if (swipeDirection == SwipeDirection.Backward) {            Log.d("SWIPE", "Swipped Backward");        } else {            Log.d("SWIPE", "Unknown Swipe");        }    }    public boolean onScroll(MotionEvent arg0, MotionEvent arg1, float arg2, float arg3) {        Log.e(TAG, "Angle mover called");        GVREyePointeeHolder pickedHolder = getEyePointee();        if (pickedHolder != null)            controller.onScrollOverModel(pickedHolder, arg2);        return false;    }    public void zoomCurrentModel(float zoomBy) {        controller.onZoomOverModel(zoomBy);    }}