/* Copyright 2015 Samsung Electronics Co., LTD * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.gearvrf.modelviewer2;import org.gearvrf.GVRActivity;import org.gearvrf.GVRAndroidResource;import org.gearvrf.GVRAssetLoader;import org.gearvrf.GVRContext;import org.gearvrf.GVREyePointeeHolder;import org.gearvrf.GVRMaterial;import org.gearvrf.GVRMesh;import org.gearvrf.GVRMeshEyePointee;import org.gearvrf.GVRPicker;import org.gearvrf.GVRRenderData;import org.gearvrf.GVRScene;import org.gearvrf.GVRSceneObject;import org.gearvrf.GVRScript;import org.gearvrf.GVRTexture;import org.gearvrf.animation.GVRRotationByAxisAnimation;import org.gearvrf.scene_objects.GVRModelSceneObject;import org.gearvrf.scene_objects.GVRSphereSceneObject;import org.gearvrf.scene_objects.GVRTextViewSceneObject;import org.gearvrf.util.BoundingBoxCreator;import org.gearvrf.util.VRTouchPadGestureDetector.SwipeDirection;import org.gearvrf.animation.GVRAnimation;import org.gearvrf.utility.Exceptions;import org.gearvrf.widgetplugin.GVRWidgetPlugin;import org.gearvrf.widgetplugin.GVRWidgetSceneObject;import org.gearvrf.widgetplugin.GVRWidgetSceneObjectMeshInfo;import org.joml.Vector3f;import android.graphics.Color;import android.opengl.GLES20;import android.os.Environment;import android.util.Log;import android.view.Gravity;import android.view.MotionEvent;import java.io.BufferedReader;import java.io.File;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.ArrayList;import java.util.Random;import java.util.Scanner;import java.util.concurrent.Future;public class ModelViewer2Manager extends GVRScript {    private static final String TAG = "Abhijit";    private GVRContext mGVRContext;    private GVRModelSceneObject mRoom;    private ArrayList<GVRSceneObject> allModels = null;    private ArrayList<GVRSceneObject> currentThumbNailsInRoom = new ArrayList<GVRSceneObject>();    private ArrayList<GVRAnimation> aAnimation = new ArrayList<GVRAnimation>();    private ArrayList<String> listOfAllModels = null;    private GVRTextViewSceneObject textMessage = null;    private final String mRoomPath = "room.fbx";    private GVRScene scene;    private boolean mIsSingleTapped = false;    private Model currentDisplayedModel = null;    GVRSceneObject tempModelSO;    private static final int gSlots = 3;    private int gStart = 0;    private ArrayList<Model> aModel = new ArrayList<Model>();    private String sEnvironmentPath = Environment.getExternalStorageDirectory().getPath();    GVRSceneObject headTracker;    GVRWidgetPlugin mPlugin;    GVRWidgetSceneObject mWidgetButtonObject;    SkyBox skyBoxModels = null;    GVRActivity activity;    private Vector3f defaultCameraPosition = new Vector3f(0, 200, 1000);    CameraPosition objectCameraPosition = new CameraPosition(defaultCameraPosition.x, defaultCameraPosition.y, defaultCameraPosition.z);    public ModelViewer2Manager(GVRActivity activity, GVRWidgetPlugin mPlugin, String skyBoxList[]) {        skyBoxModels = new SkyBox(skyBoxList);        this.mPlugin = mPlugin;        this.activity = activity;    }    private GVRModelSceneObject loadModelFile(GVRContext gvrContext, String modelFile) {        try {            return gvrContext.loadModel(modelFile);        } catch (IOException e) {            e.printStackTrace();        }        return null;    }    private GVRTexture loadTexture(GVRContext gvrContext, String imageFile) {        try {            return gvrContext.loadTexture(new GVRAndroidResource(gvrContext, imageFile));        } catch (IOException e) {            e.printStackTrace();        }        return null;    }    private ArrayList<String> getListOfModels() {        ArrayList<String> listOfAllModels = new ArrayList<String>();        // Add All the Extensions you want to load        ArrayList<String> extensions = new ArrayList<String>();        extensions.add(".fbx");        extensions.add(".3ds");        extensions.add(".dae");        extensions.add(".obj");        extensions.add(".ma");        // Reads the List of Files from specified folder having extension specified in extensions.        // Please place your models by creating GVRModelViewer2 folder in your internal phone memory        CardReader cRObject = new CardReader(sEnvironmentPath + "/GVRModelViewer2", extensions);        File list[] = cRObject.getModels();        if (list == null)            return listOfAllModels;        // Adds all the models        for (File file : list) {            //Log.e("FBx File", file.getAbsolutePath());            listOfAllModels.add(file.getName());        }        return listOfAllModels;    }    private void addThumbNailsToTheRoom() {        Log.d(TAG, "Adding all thumbnails to the Room");        int lSlots = gSlots;        int count = aModel.size();        float xPosition = -2.0f;        GVRAnimation animation;        for (int i = 0; i < currentThumbNailsInRoom.size(); i++) {            animation = new GVRRotationByAxisAnimation(currentThumbNailsInRoom.get(i), 2, 360, 0, 1, 0).start(mGVRContext.getAnimationEngine());            //animation.setRepeatMode(1);            animation.setRepeatCount(-1);            aAnimation.add(animation);        }        for (int i = 0; i < currentThumbNailsInRoom.size(); i++) {            while (!aAnimation.get(i).isFinished()) {            }        }        for (int i = 0; i < currentThumbNailsInRoom.size(); i++) {            mGVRContext.getAnimationEngine().stop(aAnimation.get(i));        }        aAnimation.clear();        for (GVRSceneObject oneChild : currentThumbNailsInRoom) {            mRoom.removeChildObject(oneChild);        }        for (int i = gStart; i < count; ) {            aModel.get(i).thumbnail.getTransform().setPosition(xPosition, 205.0f, 980.0f);            xPosition += 6.0;            mRoom.addChildObject(aModel.get(i).thumbnail);            currentThumbNailsInRoom.add(aModel.get(i).thumbnail);            lSlots--;            i = (i + 1) % count;            gStart = i;            if (lSlots == 0) {                break;            }        }    }    private GVRSceneObject getHeadTracker() {        // Head Tracker        GVRTexture headTrackerTexture = loadTexture(mGVRContext, "head-tracker.png");        headTracker = new GVRSceneObject(mGVRContext,                mGVRContext.createQuad(0.5f, 0.5f), headTrackerTexture);        headTracker.getTransform().setPositionZ(-9.0f);        headTracker.getRenderData().setRenderingOrder(                GVRRenderData.GVRRenderingOrder.OVERLAY);        headTracker.getRenderData().setDepthTest(false);        headTracker.getRenderData().setRenderingOrder(100000);        return headTracker;    }    void displayCountInRoom() {        GVRTextViewSceneObject count = getTextViewSceneObject("Total Models " + String.valueOf(aModel.size()), 10, Color.BLUE, -2.0f, 207.0f, 985.0f);        mRoom.addChildObject(count);    }    void createModels(ArrayList<String> listOfAllModels) {        for (String modelName : listOfAllModels) {            Model tempModel = new Model(modelName, "GVRModelViewer2/");            tempModel.addThumbnail(mGVRContext);            aModel.add(tempModel);        }    }    void addWidgetToTheRoom() {        GVRWidgetSceneObjectMeshInfo info =                new GVRWidgetSceneObjectMeshInfo(-4.5f, 1.0f, -1.5f, -1.0f, new int[]{0, 0}, new int[]{1280 * 2, 1440 * 2});        mWidgetButtonObject = new GVRWidgetSceneObject(mGVRContext,                mPlugin.getTextureId(), info, mPlugin.getWidth(),                mPlugin.getHeight());        Log.e(TAG, Float.toString(mPlugin.getHeight()) + "   " + Float.toString(mPlugin.getWidth()));        mWidgetButtonObject.getTransform().setPosition(defaultCameraPosition.x - 3.0f, defaultCameraPosition.y, defaultCameraPosition.z - 5);        mWidgetButtonObject.getTransform().rotateByAxis(40.0f, 0.0f, 1.0f, 0.0f);        mWidgetButtonObject.getRenderData().setRenderingOrder(                GVRRenderData.GVRRenderingOrder.OVERLAY);        mWidgetButtonObject.getRenderData().setDepthTest(false);        mWidgetButtonObject.getRenderData().setRenderingOrder(10000);        scene.addSceneObject(mWidgetButtonObject);        GVRMesh button_pick_mesh = null;        try {            button_pick_mesh = mGVRContext                    .loadMesh(new GVRAndroidResource(mGVRContext, "widgetEyePointee.obj"));        } catch (IOException e) {            e.printStackTrace();            Log.e(TAG, "Execption for button");        }        GVREyePointeeHolder eyePointeeHolder2 = new GVREyePointeeHolder(                mGVRContext);        GVRMeshEyePointee eyePointee2 = new GVRMeshEyePointee(mGVRContext,                button_pick_mesh);        eyePointeeHolder2.addPointee(eyePointee2);        mWidgetButtonObject.attachEyePointeeHolder(eyePointeeHolder2);    }    void initializeCameraPositions(){        objectCameraPosition.addCameraPosition(defaultCameraPosition.x - 3.0f, defaultCameraPosition.y, defaultCameraPosition.z);        objectCameraPosition.addCameraPosition(defaultCameraPosition.x, defaultCameraPosition.y + 5, defaultCameraPosition.z);        objectCameraPosition.addCameraPosition(defaultCameraPosition.x, defaultCameraPosition.y, defaultCameraPosition.z + 10);    }    String readFile(String File){        BufferedReader reader = null;        String readContents = "";        try {            reader = new BufferedReader(                    new InputStreamReader(activity.getAssets().open(File), "UTF-8"));            // do reading, usually loop until end of file reading            String mLine;            while ((mLine = reader.readLine()) != null) {                //process line                readContents += mLine;                readContents += "\n";            }        } catch (IOException e) {            e.printStackTrace();        }        return readContents;    }    private GVRRenderData attachTexture(GVRContext context, String modelPath, String vertexShaderPath, String fragmentShaderPath) {        ShaderHandler shaderHandler = new ShaderHandler(context);        GVRRenderData renderData = new GVRRenderData(context);        GVRMesh mesh = null;        GVRMaterial material = null;        try {            String vertexShader = readFile(vertexShaderPath);            String fragmentShader = readFile(fragmentShaderPath);            shaderHandler.addVSandFS(vertexShader, fragmentShader);            material = new GVRMaterial(context, shaderHandler.getShaderID());            mesh = context.loadMesh(new GVRAndroidResource(context, modelPath));        } catch (IOException e) {            e.printStackTrace();            System.out.print(e);        }        Log.e(TAG, "Shaders custom aadded");        renderData.setMesh(mesh);        renderData.setMaterial(material);        return renderData;    }    @Override    public void onInit(final GVRContext gvrContext) {        mGVRContext = gvrContext;        scene = gvrContext.getNextMainScene();        // Add Head Tracker        scene.getMainCameraRig().addChildObject(getHeadTracker());        scene.getMainCameraRig().getTransform().setPosition(defaultCameraPosition.x, defaultCameraPosition.y, defaultCameraPosition.z);        // Set the near clipping plane.        scene.getMainCameraRig().setNearClippingDistance(0.1f);        // Set the far clipping plane.        scene.getMainCameraRig().setFarClippingDistance(4500.0f);        // Load the Room model twice        mRoom = loadModelFile(gvrContext, mRoomPath);        //mRoomWithMenu = loadModelFile(gvrContext, mRoomPath);        // Set Transformations        mRoom.getTransform().setPosition(0.0f, 0.0f, 0.0f);        //GVRRenderData renderData = attachTexture(mGVRContext, mRoomPath, "Holo.vert", "Holo.frag");        //mRoom.attachRenderData(renderData);        //scene.bindShaders();        //mRoomWithMenu.getTransform().setPosition(0.0f, 0.0f, 0.0f);        /* Get List of Model and do the following            1. Create its thumbNail and text            2. Add Eye Pointee for thumbnail        */        createModels(getListOfModels());        Log.e(TAG, "Model creation done");        /* Add All Required things to Room            1. Displays Count            2. [N = Slots] ThumbNails            3. Widget Or Menu         */        displayCountInRoom();        addThumbNailsToTheRoom();        //initializeCameraPositions();        addWidgetToTheRoom();        // Adding Room to the Final Scene        scene.addSceneObject(mRoom);        // Add First SkyBox        addSkyBox(0);    }    ArrayList<String> getCameraPositionList(){        ArrayList<String> list = new ArrayList<String>();        ArrayList<Vector3f> tempList = objectCameraPosition.getAllCameraPositions();        for(Vector3f position : tempList){            String sPosition = "X:" + Float.toString(position.x) + " Y:" + Float.toString(position.y) + " Z:" + Float.toString(position.z);            list.add(sPosition);        }        return list;    }    void addSkyBox(int index) {        Log.e(TAG, "Adding SkyBox");        GVRSphereSceneObject previous = skyBoxModels.getCurrentSkyBox();        if (previous != null)            scene.removeSceneObject(previous);        GVRSphereSceneObject current = skyBoxModels.getSkyBox(mGVRContext, index);        if (current != null) {            scene.addSceneObject(current);            current.getTransform().setPosition(0.0f, 200.0f, 1000.0f);        }    }    void changeCameraPosition(int index){        Log.e(TAG, "Camera Position Chosed +" + Integer.toString(index));        Vector3f position = objectCameraPosition.getIndexedCameraPosition(index);        scene.getMainCameraRig().getTransform().setPosition(position.x, position.y, position.z);        if(mWidgetButtonObject != null)        mWidgetButtonObject.getTransform().setPosition(position.x - 3.0f, position.y, position.z - 5);    }    String[] getSkyBoxList() {        return skyBoxModels.skyBoxNameList;    }    GVRTextViewSceneObject getTextViewSceneObject(String text, int size, int color, float posX, float posY, float posZ) {        GVRTextViewSceneObject textObject = new GVRTextViewSceneObject(mGVRContext, text);        textObject.setGravity(Gravity.CENTER);        textObject.setTextSize(size);        textObject.setTextColor(color);        textObject.getTransform().setPosition(posX, posY, posZ);        textObject.getRenderData().setRenderingOrder(GVRRenderData.GVRRenderingOrder.TRANSPARENT);        return textObject;    }    void showMessage(String message) {        textMessage = getTextViewSceneObject(message, 10, Color.BLUE, -1.0f, 200.0f, 995.0f);        mRoom.addChildObject(textMessage);    }    void removeThumbNailsFromCurrentScene() {        for (GVRSceneObject thumbNail : currentThumbNailsInRoom) {            mRoom.removeChildObject(thumbNail);        }    }    @Override    public void onStep() {        boolean isSingleTapped = mIsSingleTapped;        mIsSingleTapped = false;        GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT | GLES20.GL_DEPTH_BUFFER_BIT);        GVREyePointeeHolder[] pickedHolders = null;        pickedHolders = GVRPicker.pickScene(mGVRContext.getMainScene());        //Log.e(TAG, "Picked scene count" + Integer.toString(pickedHolders.length));        // For Menu        if (pickedHolders.length > 0) {            mPlugin.setPickedObject(pickedHolders[0].getOwnerObject());        }        if (isSingleTapped) {            for (GVREyePointeeHolder holder : pickedHolders) {                if (holder.equals(mWidgetButtonObject.getEyePointeeHolder())) {                    Log.e(TAG, "TOuch event for widget only");                    return;                }            }            // If Tapped On Current Model Close It            if (currentDisplayedModel != null && pickedHolders[0].equals(currentDisplayedModel.model.getEyePointeeHolder())) {                mRoom.removeChildObject(currentDisplayedModel.getModel(mGVRContext));                // Set Camera Position to Default                changeCameraPosition(0);                Log.e(TAG, "TApped on Model so displaying THumbNail");                // Add ThumbNails already present before                for (GVRSceneObject thumbnail : currentThumbNailsInRoom) {                    mRoom.addChildObject(thumbnail);                }                currentDisplayedModel = null;                return;            }            // Else Check if A thumbNal is selected            for (int index = 0; index < aModel.size(); index++) {                if (pickedHolders[0].equals(aModel.get(index).thumbnail.getEyePointeeHolder())) {                    // Remove Old Model If any                    if (currentDisplayedModel != null) {                        mRoom.removeChildObject(currentDisplayedModel.getModel(mGVRContext));                        currentDisplayedModel = null;                        // Reset Camera Position to Default                        scene.getMainCameraRig().getTransform().setPosition(defaultCameraPosition.x, defaultCameraPosition.y, defaultCameraPosition.z);                        mWidgetButtonObject.getTransform().setPosition(defaultCameraPosition.x - 3.0f, defaultCameraPosition.y, defaultCameraPosition.z - 5);                    }                    // Remove Old Message If any                    if (textMessage != null)                        mRoom.removeChildObject(textMessage);                    // Remove Old Thumbanail                    removeThumbNailsFromCurrentScene();                    Log.d(TAG, "Called Loading Model");                    showMessage("Loading");                    tempModelSO = aModel.get(index).getModel(mGVRContext);                    mRoom.addChildObject(tempModelSO);                    Log.d(TAG, "Loading Done");                    if (tempModelSO != null) {                        mRoom.removeChildObject(textMessage);                        mRoom.addChildObject(tempModelSO);                        Log.d(TAG, "Loading Done");                        currentDisplayedModel = aModel.get(index);                        scene.addSceneObject(mRoom);                        scene.bindShaders();                    } else {                        showMessage("Error Loading Model");                    }                    break;                }            }        }    }    public void onSingleTap(MotionEvent e) {        Log.d(TAG, "On Single Touch Received");        mIsSingleTapped = true;    }    public void onSwipe(MotionEvent e, SwipeDirection swipeDirection,                        float velocityX, float velocityY) {        if (swipeDirection == SwipeDirection.Forward) {            // Swipe Only when Looking at ThumbNails            GVREyePointeeHolder[] pickedHolders = null;            pickedHolders = GVRPicker.pickScene(mGVRContext.getMainScene());            for (GVREyePointeeHolder holder : pickedHolders) {                for (int i = 0; i < currentThumbNailsInRoom.size(); i++) {                    if (holder == currentThumbNailsInRoom.get(i).getEyePointeeHolder()) {                        addThumbNailsToTheRoom();                        return;                    }                }            }            Log.d("SWIPE", "Swipped Forward");        } else if (swipeDirection == SwipeDirection.Backward) {            Log.d("SWIPE", "Swipped Backward");        } else {            Log.d("SWIPE", "Unknown Swipe");        }    }    public boolean onScroll(MotionEvent arg0, MotionEvent arg1, float arg2, float arg3) {        Log.e(TAG, "Angle mover called");        GVREyePointeeHolder[] pickedHolders = null;        pickedHolders = GVRPicker.pickScene(mGVRContext.getMainScene());        Log.e(TAG, Integer.toString(pickedHolders.length));        GVRAnimation animation = null;        if (currentDisplayedModel != null) {            for (GVREyePointeeHolder holder : pickedHolders) {                if (holder == currentDisplayedModel.getModel(mGVRContext).getEyePointeeHolder()) {                    Log.e(TAG, "Angle mover applied");                    if (arg2 > 0)                        animation = new GVRRotationByAxisAnimation(currentDisplayedModel.getModel(mGVRContext), 0.1f, 35, 0, 1, 0).start(mGVRContext.getAnimationEngine());                    else                        animation = new GVRRotationByAxisAnimation(currentDisplayedModel.getModel(mGVRContext), 0.1f, 35, 0, -1, 0).start(mGVRContext.getAnimationEngine());                }            }        }        return false;    }    public Model getCurrentDisplayedModel() {        return currentDisplayedModel;    }    public void zoomCurrentModel(float zoomBy) {        // User is at 1000 and Object is at 980        float zTransform = (1010.f - 980.f) / (100.0f - zoomBy);        Log.e(TAG, "Zoom by" + Float.toString(zTransform));        if (currentDisplayedModel != null)            currentDisplayedModel.getModel(mGVRContext).getTransform().setPositionZ(980.0f + zTransform);    }}